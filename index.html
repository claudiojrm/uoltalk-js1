<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>UOLTalk - Javascript (Módulo I)</title>
		<link rel="shortcut icon" href="https://hp.imguol.com.br/c/home/layout/camaleao/web/gerais/favicon.ico">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/night.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">
		<style>
			.highlight{color:#e7ad52!important;}
			pre, code { font-size: 17px!important; }
		</style>
		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<section>
						<h2 class="highlight">UOLTalk</h2>
					</section>
					<section>
						<p>O que é o <span class="highlight">UOLTalk</span>?</p>
					</section>
					<section>
						<p>São reuniões periódicas, apresentando conteúdos relevantes para o nosso dia a dia.</p>
					</section>
					<section>
						<p>Os objetivos do <span class="highlight">UOLTalk</span> são:</p>
						<ul>
							<li class="fragment">compartilhar conhecimento</li>
							<li class="fragment">padronizar código</li>
							<li class="fragment">evoluir equipe</li>
						</ul>
					</section>					
				</section>
				
				<section>
					<section>						
						<b class="highlight">UOLTalk Javascript</b> <br> (Módulo I)
					</section>
					<section>
						<p>O que abordaremos?</p>
						<ul class="highlight">
                            <li class="fragment">Escopo</li>
                            <li class="fragment">Statements</li>
                            <li class="fragment">Protótipo</li>
                            <li class="fragment">Funções</li>
                            <li class="fragment">Instâncias</li>
                            <li class="fragment">Ajax</li>
                            <li class="fragment">Promise</li>
							<li class="fragment">Tipos</li>
							<li class="fragment">Boas práticas</li>
						</ul>
					</section>
				</section>
	
				<section>
					"A linguagem javascript é a única que as pessoas <span class="highlight">acham que não precisam aprender</span> antes de começar a utilizar." <i>- Douglas Crockford</i>
				</section>

                <section>
                    <section>
                        <b class="highlight">Escopo</b>
					</section>

					<section>
						<p>O que abordaremos?</p>
						<ul class="highlight">
							<li class="fragment">O que é escopo?</li>
							<li class="fragment">Escopo global</li>
							<li class="fragment">Escopo local</li>
							<li class="fragment">Escopo de função</li>
							<li class="fragment">Escopo dos parâmetros de função</li>
							<li class="fragment">Precedência de variáveis</li>
							<li class="fragment">Içamento (Hoisting)</li>
						</ul>
					</section>

					<section>
						O que é <span class="highlight">Escopo</span>?
						<p class="fragment"><i>O escopo de uma variável é a região <br>do código onde ela é definida.</i></p>
					</section>

					<section>
						<p>Uma variável <span class="highlight">global</span> tem escopo <span class="highlight">global</span> e está definida em toda a parte do código.</p>
					</section>

					<section>
						<p>Por outro lado, variáveis declaradas dentro <br> de uma <span class="highlight">função</span> estão definidas apenas dentro do corpo da função. Elas são <span class="highlight">variáveis locais</span><br> e têm seu <span class="highlight">escopo local</span>.</p>
					</section>

					<section>
						<p>Os <span class="highlight">parâmetros das funções</span> também contam <br>como variáveis locais e estão definidas<br> apenas dentro da função.</p>
					</section>

					<section>
						<p>Uma variável local tem precedência sobre uma variável global com o mesmo nome, ou seja, a variável global é ocultada pela variável local.</p>
						<pre class="fragment">
							<code>var scope = 'global';

function checkScope() {
    var scope = 'local';
    return scope;
}

console.log(checkScope()); // => a saída será "local"
							</code>
						</pre>
					</section>

					<section>
						<p>Embora seja possível a não utilização da <br>instrução <span class="highlight">var</span> no escopo global, ela  <br>deve ser sempre utilizada para declaração <br>em escopo local. Considere o seguinte:</p>
						<pre class="fragment">
							<code>scope = 'global';

function checkScope() {
    scope = 'local';
    myscope = 'local';
    return [scope, myscope]
}

console.log(checkScope()); // => a saida será ['local', 'local'], a variavel foi afetada.
console.log(scope); // => 'local'
console.log(myscope); // => 'local'
							</code>
						</pre>
					</section>

					<section>
						<p>Cada função tem seu próprio escopo, <br> portanto é possível ter várias camadas <br>de escopo local aninhadas:</p>
						<pre class="fragment">
							<code>var scope = 'global scope';
function checkScope() {
    var scope = 'local scope';
    function nested() {
        var scope = 'nested scope';
        return scope;
    }
    return nested();
}

console.log(checkScope()); // => A saída será "nested scope"
							</code>
						</pre>
					</section>

					<section>
						<p>No escopo de função, as variáveis são visíveis dentro da função de dentro de qualquer função que esteja aninhada dentro dela.</p>
					</section>

					<section>
						<p>No exemplo a seguir, as variáveis <span class="highlight">i</span>, <span class="highlight">j</span> e <span class="highlight">k</span> são declaradas em diferentes pontos, mas <br>todas tem o mesmo escopo.</p>
						<pre class="fragment">
							<code>function test(o) {
    var i = 0; // i está definida para toda a função
    if(typeof o == 'object') {
        var j = 0; // j está definida para toda a função e não apenas no bloco
        for(var k = 0; k < 10; k++) { // k está definida para toda a função e não apenas no bloco
            console.log(k); // imprime os números de 0 a 9
        }
        console.log(k); // k ainda está definida e imprime 10
    }
    console.log(j); // j está definida, mas não pode ser inicializada
}

test({str: 'fagneranabalada'});</code>
						</pre>
					</section>

					<section>
						<p>O <span class="highlight">escopo de função</span> em JavaScript significa que todas as <span class="highlight">variáveis</span> declaradas dentro da função são visíveis por todo o <span class="highlight">corpo da função</span>.</p>
					</section>

					<section>
						<p>Isso significa que as variáveis são visíveis antes mesmo de serem declaradas. Essa característica em JavaScript é chamada de <span class="highlight">içamento</span>.</p>
						<p class="fragment"><small>* Veja mais sobre <a target="_blank" href="https://developer.mozilla.org/pt-BR/docs/Glossario/Hoisting">Içamento (Hoisting)</small></a></p>
					</section>

					<section>
						<p>O código se comporta como se todas as declarações de variáveis fossem <br>içadas para o todo da função.</p>
						<pre class="fragment">
							<code>var scope = 'global';
function test() {
    console.log(scope); // => A saida será "undefined" e não "global" ou "ReferenceError"
    var scope = 'local'; // variavel inicializada aqui, mas visivel para todo o corpo
    console.log(scope); // => A saida será "local"
}
test();</code>
						</pre>
					</section>

					<section>
						<p>...é equivalente a:</p>
						<pre class="fragment">
							<code>function test() {
    var scope;
    console.log(scope); // => A saida será "undefined" e não "global" ou "ReferenceError"
    var scope = 'local'; // variavel inicializada aqui, mas visivel para todo o corpo
    console.log(scope); // => A saida será "local"
}
test();</code>
						</pre>
					</section>

					<section>
						<p>É uma boa prática declarar as variáveis no início das funções, em vez de tentar declarar mais próximo ao ponto em que são utilizadas. <br>Isso reflete mais precisamente o <br>verdadeiro escopo das variáveis.</p>
					</section>

					<section>
						<b class="highlight">É isso, próximo!</b>
					</section>
				</section>

				<section>
					<section>
						<b class="highlight">Statements</b>
					</section>

					
					<section>
						<p>O que abordaremos?</p>
						<ul class="highlight">
							<li class="fragment">for in</li>
							<li class="fragment">for</li>
							<li class="fragment">while</li>
							<li class="fragment">break</li>
                            <li class="fragment">continue</li>
                            <li class="fragment">labelled + break</li>
                            <li class="fragment">if, else if e else</li>
                            <li class="fragment">switch</li>
							<li class="fragment">try catch</li>
                            <li class="fragment">throw</li>
                            <li class="fragment">var</li>
						</ul>
					</section>
					
					<section>
						<p><span class="highlight">for in</span></p>
						<p class="fragment">Para valores de objetos interáveis: <br>string, array, array-like, Set, Map <br>(um objeto simples não é interável)</p>
						<pre class="fragment">
							<code>var a = ['a', 'b', 'c'];

for (var x in a) {
    // 0, 1, 2
}
</code>
						</pre>
					</section>

					<section>
						<p><span>ou</span></p>
						<pre class="fragment">
							<code>var a = { nome : 'fagnera', sobrenome : 'nabalada' };

for (var x in a) {
    // nome, sobrenome
    // para se obter o valor do objeto a[x] - fagnera, nabalada
}</code>
						</pre>
					</section>

					<section>
						<p><span class="highlight">for</span></p>
                        <p class="fragment"><i>construção/escopo; condição; pós execução</i></p>
						<pre class="fragment">
							<code>for(var x = a.length, y = 0; x--; ++y) {
    // 2, 0
    // 1, 1
    // 0, 2
}
</code>
						</pre>
					</section>

					<section>
						<p><span class="highlight">while</span></p>
						<pre class="fragment">
							<code>while (true) {
    // sentindo cheiro de queimado?
}</code>
						</pre>
					</section>

					<section>
						<p><span class="highlight">break</span></p>
                        <p class="fragment"><i>interrompe a execução</i></p>
						<pre class="fragment">
							<code>var a = ['a', 'b', 'c'];

for(var x in a) {
    if (x == 1) {
        break;
    }

    console.log(x);
    // 0
}
</code>
						</pre>
					</section>

					<section>
						<p><span class="highlight">continue</span></p>
                        <p class="fragment"><i>salta a execução</i></p>
						<pre class="fragment">
							<code>for(var x in a) {
    if (x == 1) {
        continue;
    }

    console.log(x);
    // 0, 2
}
</code>
						</pre>
					</section>

					<section>
						<p><span class="highlight">Labelled + break</span></p>
						<p class="fragment">Bloco de execução nomeado (labelled) que pode ser interrompido por break (lembra try catch)</p>
						<pre class="fragment">
							<code>meuBloco: {
    if(true) {
        var a = false;
    }

    c++;

    if(c == 2) {
        break meuBloco;
    }
    
    c = 3;
}</code>
						</pre>
					</section>

                    <section>
                        <p><span class="highlight">if</span>, <span class="highlight">else if</span> e <span class="highlight">else</span></p>
                        <p class="fragment">Condição se, ou então se ou então.</p>
                        <p class="fragment">se agora for cedo; ou então se agora for tarde; <br>ou então qualquer coisa desde que <br>agora não seja cedo e tarde.</p>
                    </section>

                    <section>
                        <pre>
                            <code>if (a == 1) {
    // faça algo se for 1
}
else if (a == 2) {
    // faça algo se for 2
}
else if (a == 3) {
    // faça algo se for 3
}
else {
    // faça algo se for tudo diferente de 1, 2 e 3
}</code>
                        </pre>
                    </section>

                    <section>
                        <p><span class="highlight">switch</span></p>
                        <pre class="fragment">
                            <code>switch(a) {
    case 1:
        break;
    case 2:
        break;
    case 3:
        break;
    default:
        break;
}
</code>
                        </pre>
                    </section>

                    <section>
                        <p><span class="highlight">try</span>, <span class="highlight">catch</span></p>
                        <pre class="fragment">
                            <code>var resp = JSON.parse('"erro');</code>
                        </pre>
                        <p class="fragment">JSON.parse poderia retonar null ou false ao falhar. Mas o que difere de JSON.parse("null").</p>
                    </section>

                    <section>
                        <p>Exceções são erros que tendem a ser mais claros, no exemplo acima poderia informar a falta de <br>uma aspas e que podem navegar por <br>camadas até encontrar <span class="highlight">try catch</span>.</p>
                    </section>

                    <section>
                        <pre>
                            <code>try {
    var resp = JSON.parse('"erro');
} catch (e) {
    console.log(e);
    // SyntaxError: Unexpected end of JSON input
}
</code>
                        </pre>
                    </section>

                    <section>
                        <p><span class="highlight">throw</span></p>
                        <p class="fragment"><i>Cria exceções.</i></p>
                        <pre class="fragment">
                            <code>if(a > 1) {
    throw 'A não pode ser maior que 1';
}

throw new Error('mensagem');
</code>
                        </pre>
                    </section>

                    <section>
                        <p><span class="highlight">var</span></p>
                        <p class="fragment">Variáveis globais, locais e constantes.</p>
                    </section>

                    <section>
                        <b class="highlight">É isso, próximo!</b>
                    </section>
				</section>
		
				<section>
					<section>
						<b class="highlight">Protótipo</b>
					</section>

					<section>
						<p>O que abordaremos?</p>
						<ul class="highlight">
							<li class="fragment">O que é protótipo?</li>
							<li class="fragment">Herança</li>
							<li class="fragment">Herança prototípica</li>
							<li class="fragment">Protótipos em instâncias</li>
							<li class="fragment">Protótipos em tipos primitivos</li>
							<li class="fragment">Subclasse</li>
						</ul>
					</section>

					<section>
						O que é <span class="highlight">Protótipo</span>?
						<p class="fragment"><i>Em JavaScript, um prototype é uma propriedade de funções e de objetos que são criados por funções de construtor. O protótipo de uma função é um objeto. Seu principal uso é quando uma função é usada como um construtor.</i></p>
					</section>

					<section>
						<p>Em OOP, <span class="highlight">herança</span> refere-se a habilidade de um objeto acessar métodos e outras propriedades de outro objeto. Estes objetos então herdam essas informações de outros objetos e podem <br>utilizá-las da forma que preferirem.</p>
					</section>

					<section>
						<p>No JavaScript não temos uma herança propriamente dita, mas ela funciona através <br>do que são chamados de <span class="highlight">protótipos</span>.</p>
					</section>

					<section>
						<p>Esta forma de herança é conhecida como <br><span class="highlight">herança prototípica</span> (ou <span class="highlight">_prototypal inheritance_</span>).</p>
					</section>

					<section>
						<p>Pense no seguinte cenário:</p>
						<p class="fragment">Temos nossa classe <span class="highlight">Carro</span>, que se encontra vazia e queremos anexar um <span class="highlight">método</span> a ela. Logo utilizamos a seguinte estrutura:</p>
					</section>

					<section>
						<pre>
							<code>function Carro(){}

Carro.prototype.andar = function(){
    return true;
}

var meuCarro = new Carro();
console.log(meuCarro.andar()); // => true</code>
						</pre>
					</section>

					<section>
						<p>Um protótipo nos permite predefinir propriedades, incluindo métodos. Você pode saber como <br>acessar as propriedades de protótipos a <br>partir da instância do objeto com <span class="highlight">meuCarro.constructor.prototype.andar</span>.</p>
					</section>

					<section>
						<p>A ordem de declaração do protótipo não importa, uma vez que sua atualização é "dinâmica". Então:</p>
						<pre class="fragment">
							<code>function Carro(){}

Carro.prototype.andar = function(){
    return true;
}

var meuCarro = new Carro();

Carro.prototype.parar = function(){
    return true;
}

console.log(meuCarro.parar());</code>
						</pre>
					</section>

					<section>
						<p>...é o mesmo que:</p>
						<pre class="fragment">
							<code>function Carro(){}

Carro.prototype.andar = function(){
    return true;
}

Carro.prototype.parar = function(){
    return true;
}

var meuCarro = new Carro();

console.log(meuCarro.parar())</code>
						</pre>
					</section>

					<section>
						<p>Podemos também instânciar <br>um objeto deste modo:</p>
						<pre class="fragment">
							<code>function Carro(){}

var meuCarro = new Carro();
var meuSegundoCarro = new meuCarro.constructor();

console.log("Verificanco se esta afirmação é verdadeira: " + meuCarro !== meuSegundoCarro);</code>
						</pre>
						<p class="fragment">Note que <span class="highlight">meuCarro</span> não é o <br> mesmo objeto de <span class="highlight">meuSegundoCarro</span>, <br>mas são duas instâncias distintas.</p>
					</section> 
					
					<section>
						<p>Existem várias formas de como obter uma <br>herança com protótipos, mas sem dúvida,<br> a melhor forma é este modo:</p>
					</section>

					<section>
						<pre>
							<code>function Carro(){
    this.andar = function(){
        return true;
    }
} 

function Acessorios(){
    this.ligarRadio = function(){
        console.log("ligou o radio");
    }
}

// "Carro" agora herda "Acessorios"
Carro.prototype = new Acessorios();
meuCarro = new Carro();

// verificando
console.log(meuCarro instanceof Carro); // => true
console.log(meuCarro instanceof Acessorios); // => true</code>
						</pre>
					</section>

					<section>
						<p>Outra forma, porém não aconselhável é utilizar o objeto do protótipo de "Acessorios" diretamente como protótipo de "Carro".</p>
						<p class="fragment"><span class="highlight">Ex: Carro.prototype = Acessorios.prototype;</span></p>
					</section>

					<section>
						<p>Fazendo isto, qualquer alteração no protótipo <br>de "Carro" também modificará o protótipo de "Acessorios", pois serão o mesmo objeto. <br>Isso não é aconselhável porque pode gerar <br> <span class="highlight">efeitos colaterais indesejáveis</span>.</p>
					</section>

					<section>
						<p>Os protótipos nos permite também estender os tipos primitivos do javascript, como <br><span class="highlight">Object</span>, <span class="highlight">Array</span>, <span class="highlight">Number</span> e etc.</p>
					</section>

					<section>
						<p><span class="highlight">Object</span></p>
						<pre class="fragment">
							<code>Object.prototype.esconde = function(callback) {
    if(this.hasOwnProperty("style")){
        this.style.opacity = 0;
        this.style.filter = "alpha(opacity=0)";
        callback.call(this,this);
    }
};
document.getElementById('escondido').esconde(function(element){
    console.log("A div com o id " + element.getAttribute("id") + "foi escondida.");
});
</code>
						</pre>
					</section>

					<section>
						<p><span class="highlight">Array</span></p>
						<pre class="fragment">
							<code>Array.prototype.meuMetodo = function(callback) {
    for(var i = 0; i < this.length; i++){
        callback.call(this,this[i],i);
    }
};
var times = ["Corinthians","São Paulo","Santos","Palmeiras"];
times.meuMetodo(function(time, index){
    console.log("Time: " + time + " sua posição é: " + index);
});
</code>
						</pre>
					</section>


					<section>
						<p><span class="highlight">Number</span></p>
						<p class="fragment">Também podemos estender o tipo Number, <br>mas não é recomendável pois ele é um <br>protótipo nativo muito problemático.</p>
					</section>

					<section>
						<p>Como explicado acima, existe um modo de herdamos heranças em classes JavaScript, <br>isso não é diferente com o objeto Array.</p>
					</section>

					<section>
						<p>Vejamos um exemplo de como podemos <br>criar uma subclasse do tipo array:</p>
						<pre class="fragment">
							<code>function MinhaClasse(){}

MinhaClasse.prototype = new Array();

var meu = new MinhaClasse();
meu.push(1,2,3);

console.log("O tamanho da subclasse meu é: "+meu.length);
</code>
						</pre>
					</section>
					
					<section>
						<b class="highlight">É isso, próximo!</b>
					</section>
				</section>
		
				<section>
					<section>
						<b class="highlight">Funções</b>
					</section>
					
					<section>
						O que é <span class="highlight">Função</span>?
						<p class="fragment"><i>É um objeto que contém um código executável, isolado, não sendo possível acessá-lo externamente.</i></p>
					</section>
					
					<section>
						<p>Para se declarar uma função <br> existem algumas formas.</p>
					</section>

					<section>
						<p class="highlight">Function Declaration</p>
						<pre class="fragment">
							<code>soma(2, 2); // retorna 4
								
function soma(a, b) {
	return a + b;
}
							</code>
						</pre>
						<p class="fragment">A função é carregada antes do <br>código ser interpretado.</p>
					</section>
					
					<section>
						<p class="highlight">Function Expression</p>
						<pre class="fragment">
							<code>var soma = function(a, b) {
	return a + b;
}

soma(2, 2); // retorna 4
							</code>
						</pre>
						<p class="fragment">A função é carregada durante <br>a interpretação do código.</p>
					</section>
					
				</section>
				
				<section>
					<section>
                        <b class="highlight">Instância</b>
                    </section>

                    <section>
                        <p>O que abordaremos?</p>
                        <ul class="highlight">
                            <li class="fragment">O que é Instância?</li>
                            <li class="fragment">Conjunto de atributos</li>
                            <li class="fragment">Concretização de uma classe</li>
                            <li class="fragment">Exemplo prático</li>
                        </ul>
                    </section>
    
                    <section>
                        O que é <span class="highlight">Instância</span>?
                        <p class="fragment"><i>Em programação orientada a objetos, instância é um objeto que tem o seu estado e comportamento definido pela classe.</i></p>
                    </section>

                    <section>
                        <p>As instâncias de uma classe compartilham o mesmo <span class="highlight">conjunto de atributos</span>, embora sejam diferentes quanto ao <span class="highlight">conteúdo desses atributos</span>.</p>
                    </section>
    
                    <section>
                        <p>Por exemplo, a classe <span class="highlight">TitleController</span> <br> descreve os atributos comuns a todas as <br> instâncias da própria classe.</p>
                    </section>

                    <section>
                        <p>Os objetos dessa classe podem ser semelhantes, mas variam em atributos. </p>
                    </section>

                    <section>
                        <p>A descrição da classe contém os itens correspondentes a esses atributos e define as operações ou ações relevantes para a classe.</p>
                    </section>

                    <section>
                        <p><i class="highlight">Instância é a concretização de uma classe.</i></p>
                        <p class="fragment">Em programação orientada a objetos, a palavra <span class="highlight">instanciar</span> significa criar. Quando falamos em instanciar um objeto, criamos fisicamente uma representação concreta da classe.</p>
                    </section>
                    
                    <section>
                        <p>Pense no seguinte cenário:</p>
                        <pre class="fragment">
                            <code>function Carro(modelo) {
    this.modelo = modelo;
}

var belina = new Carro('Belina');
var fusca = new Carro('Fusca');
</code>
                        </pre>
                    </section>

                    <section>
                        <p><span class="highlight">Carro</span> é uma classe ou um molde, <br><span class="highlight">Belina</span> é uma instância de Carro e apesar de carregar todas as características de Carro, é completamente independente de <br>outras instâncias de Carro.</p>
                    </section>
                    
                    <section>
                        <b class="highlight">É isso, próximo!</b>
                    </section>
				</section>
				
				<section>
					<section>
						<b class="highlight">Ajax</b>
					</section>

					<section>
						<p>O que abordaremos?</p>
						<ul class="highlight">
							<li class="fragment">O que é ajax?</li>
							<li class="fragment">XMLHttpRequest</li>
							<li class="fragment">readyState</li>
							<li class="fragment">onreadystatechange</li>
							<li class="fragment">Status</li>
							<li class="fragment">JSON</li>
							<li class="fragment">JSONP</li>
							<li class="fragment">Callback</li>
							<li class="fragment">Erros comuns</li>
						</ul>
					</section>
	
					<section>
						O que é <span class="highlight">Ajax</span>?
						<p class="fragment"><i>Asynchronous JavaScript e XML</i></p>
					</section>

					<section>
						<p>É o uso do objeto <span class="highlight">XMLHttpRequest</span> para se comunicar com o servidor.</p>
					
						<div class="fragment">
							<pre>
								<code>// Exemplo de requisição GET
var ajax = new XMLHttpRequest();

// Seta tipo de requisição e URL com os parâmetros
ajax.open("GET", "uol.com.br/?nome=Fagnera&sobrenome=NaBalada", true);

// Envia a requisição
ajax.send();

// Cria um evento para receber o retorno.
ajax.onreadystatechange = function() {
	// Caso o state seja 4 e o http.status for 200, é porque a requisição deu certo.
	if(ajax.readyState == 4 && ajax.status == 200) {
		var data = ajax.responseText;

		// Retorno do Ajax
		console.log(data);
	}
}
								</code>
							</pre>
							<p><small>* Veja mais sobre <a target="_blank" href="https://developer.mozilla.org/pt-BR/docs/Web/API/XMLHttpRequest" class="highlight">XMLHttpRequest</a>.</small></p>
						</div>
					</section>
						
					<section>
						<p><b class="highlight">Mas lembre-se...</b></p>
						<p class="fragment">...antes de utilizar qualquer recurso ou qualquer lib, verifique se o projeto que você está mexendo já não tem algo para isso.</p>
					</section>

					<section>
						<span class="highlight">readyState</span>
						<ul>
							<li class="fragment">0 - request não inicializado <br> <small>(método open não foi chamado)</small></li>
							<li class="fragment">1 - conexão com servidor estabelecida <br><small>(método open foi chamado)</small></li>
							<li class="fragment">2 - request recebido <br><small>(método send foi chamado, headers/status estão disponíveis)</small></li>
							<li class="fragment">3 - processando request <br><small>(baixando e o responseText contém os dados parciais)</small></li>
							<li class="fragment">4 - request finalizado e resposta pronta <br><small>(request concluído)</small></li>
						</ul>
					</section>

					<section>
						<p>A função <span class="highlight">onreadystatechange</span> é disparada toda vez que o readyState é alterado.</p>
					</section>

					<section>
						<p class="highlight">Status</p>
						<ul>
							<li class="fragment">2xx - Respostas de sucesso</li>
							<li class="fragment">3xx - Mensagens de redirecionamento</li>
							<li class="fragment">4xx - Respostas de erro do cliente</li>
							<li class="fragment">5xx - Respostas de erro do servidor</li>
						</ul>
					</section>

					<section>
						<p>Podemos enviar e<br> receber dados por:</p>
						<ul>
							<li>JSON</li>
							<li>HTML</li>
							<li>XML</li>
						</ul>
					</section>
					
					<section>
						<p>O que podemos concluir?</p>
						<p class="fragment"><i class="highlight">Ajax facilita o uso de aplicações interativas, sem que se recarregue as páginas.</i></p>
					</section>
					
					<section>
						<b class="highlight">JSON</b>
					</section>

					<section>
						O que é <span class="highlight">JSON</span>?
						<p class="fragment"><i>Javascript Object Notation</i></p>
					</section>

					<section>
						<p>JSON é um formato leve para <br> troca de dados e de fácil leitura.</p>
						<pre class="fragment">
							<code>{
	"string" : "uol.com.br",
	"number" : 2018,
	"array" : [1, 2, 3],
	"object" : { string:"uol.com.br" },
	"boolean" : true
}
							</code>
						</pre>
					</section>
					
					<section>
						<b class="highlight">JSONP</b>
					</section>

					<section>
						O que é <span class="highlight">JSONP</span>?
						<p class="fragment"><i>Javascript Object Notation <br> with Padding</i></p>
					</section>

					<section>
						<p>É um complemento ao formato JSON, <br> que disponibiliza um método para enviar requisições para um <span class="highlight">domínio diferente</span>.</p>
						<p class="fragment"><small>* Veja mais sobre <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy" class="highlight">Política de domínios diferentes</a>.</small></p>
					</section>
					
					<section>
						<p>Para cada novo request JSONP é <br> inserido uma tag <span class="highlight">script</span> no código.</p>
					</section>
	

					<section>
						<pre>
							<code>// script.js
var script = document.createElement('script');
script.src = 'http://uol.com.br/?nome=Fagner&sobrenome=NaBalada&jsonp=callback';
document.getElementsByTagName('head')[0].appendChild(script);

function callback(result) {
	// faça alguma coisa
}

// retorno do serviço
callback({
	"string" : "uol.com.br",
	"number" : 2018,
	"array" : [1, 2, 3],
	"object" : { string:"uol.com.br" },
	"boolean" : true
});</code>
						</pre>
					</section>

					<section>
						<b class="highlight">Callback</b>
					</section>

					<section>
						O que é <span class="highlight">Callback</span>?
						<p class="fragment"><i>É uma função passada a outra função <br>como parâmetro e é executada <br>para completar alguma ação.</i></p>
					</section>
					

					<section>
						<p>Pense no seguinte cenário:</p>
						<pre class="fragment">
							<code>function hello(name) {
	alert('Olá ' + name);								
}

function getName(callback) {
	var name = prompt('Qual o seu nome?');
	callback(name);
}

getName(hello);
							</code>
						</pre>
					</section>

					<section>
						<p>O exemplo anterior é um exemplo de callback síncrono, normalmente callback é utilizado após uma operação assíncrona ser finalizada.</p>
					</section>

					<section>
						<p>O erro mais comum em uma requisição ajax <br>é utilizar um <span class="highlight">parâmetro randômico</span> para a url. <br> No caso da função ajax do jQuery a opção já vem como default, isso impossibilita o servidor de guardar qualquer tipo de cache para url.</p>
					</section>

					<section>
						<b class="highlight">É isso, próximo!</b>
					</section>
				</section>

				<section>
					<section>
						<b class="highlight">Promise</b>
					</section>

					<section>
						<p>O que abordaremos?</p>
						<ul class="highlight fragment">
                            <li>O que é Promise?</li>
                            <li class="fragment">Ações assíncronas</li>
                            <li class="fragment">Status da Promise</li>
                            <li class="fragment">Resolve e rejected</li>
                            <li class="fragment">Then e catch</li>
							<li class="fragment">Exemplo prático</li>
						</ul>
					</section>

					<section>
						O que é <span class="highlight">Promise</span>?
						<p class="fragment"><i>Promise é um objeto que permite realizar processamentos assíncronos, guardando um valor que pode estar disponível agora, no futuro ou nunca. </i></p>
					</section>

					<section>
						<p>A Promise permite o tratamento de <span class="highlight">ações assíncronas</span> em casos de <span class="highlight">sucesso</span> ou <span class="highlight">falhas</span>.</p>
					</section>

					<section>
						<p>A Promise também possui diferentes <br>estados, sendo alguns deles:</p>
						<ul class="fragment highlight">
							<li>Pendente (Pending)</li>
							<li class="fragment">Resolvida (Resolved)</li>
							<li class="fragment">Rejeitada (Rejected)</li>
							<li class="fragment">Realizada (Fulfilled)</li>
							<li class="fragment">Estabelecida (Settled)</li>
						</ul>
					</section>

					<section>
						<p>Os estados mais utilizados são: <br><span class="highlight">Resolvida</span> e <span class="highlight">Rejeitada</span>.</p>
					</section>

					<section>
						<p>Ao criar uma Promise, seu estado <br>inicial é <span class="highlight">pending</span>. </p>
					</section>

					<section>
						<p>Se a mesma chegar ao estado <span class="highlight">resolved</span> é porque tudo deu certo, ou seja, a Promise foi criada, processada com sucesso.</p>
					</section>

					<section>
						<p>Porém, em caso de falhas ela  <br>entrará no modo <span class="highlight">rejected</span>.</p>
					</section>

					<section>
						<p>Uma das maneiras de fazer os <br>tratamentos de sucesso e falha é  <br>através dos métodos <span class="highlight">then</span> e <span class="highlight">catch</span>.</p>
					</section>

					<section>
						<p>Porque utilizar Promises?</p>
					</section>

					<section>
						<p>Quando utilizamos <span class="highlight">funções assíncronas</span>, <br>não conseguimos garantir o fluxo do nosso código, ou seja, um trecho de código que está localizado <span class="highlight">após</span> uma função assíncrona pode ser executado <span class="highlight">antes</span> da mesma ser realizada.</p>
					</section>

					<section>
						<pre>
							<code>function getConfig() {
    var cf;
    this.json.open('foo/bar/config.json')
        .then(function(result) {
        	cf = result;
        }).catch(function(err) {
        	console.log('Ops!', err);
        });

    return cf;
}

var config;

console.log("Abrindo o arquivo de configuração...");

config = getConfig();

console.log("Pronto!");
console.log(config);
</code>
						</pre>
					</section>

					<section>
						<p>Esse código será executado assim <br>que nossa aplicação iniciar. A ordem de <br>execução será a seguinte:</p>
						<ul class="highlight">
							<li class="fragment">Abrindo o arquivo de configuração...</li>
							<li class="fragment">Pronto!</li>
							<li class="fragment">undefined</li>
						</ul>
					</section>

					<section>
						<p>O config foi impresso como <span class="highlight">undefined</span>, pois foi avaliado antes mesmo do arquivo<br> ser aberto pela <span class="highlight">json.open</span>.</p>
					</section>

					<section>
						<p>Podemos resolver este problema assim:</p>
						<pre class="fragment">
							<code>function getConfig() {
    return this.json.open('foo/bar/config.json');
}

var config;
console.log("Abrindo o arquivo de configuração...");

getConfig().then(function(config) {
    console.log("Pronto!");
    console.log(config);
}).catch(function(e) {
    console.log(e);
});
</code>
						</pre>
					</section>

                    <section>
                        <p>Faremos uma função que simula uma requisição, assim como nossa tool de json.</p>
                        <pre class="fragment">
                            <code>function efetuaBusca() {

}
</code>
                        </pre>
                    </section>

                    <section>
                        <p>Agora podemos começar a criação de nossa Promise. Se Promise é um objeto e objetos em javascript podem ser criados ou instânciados através da palavra reservada <span class="highlight">new</span>, faremos o mesmo com nossa Promise.</p>
                    </section>

                    <section>
                        <pre>
                            <code>function efetuaBusca() {
    new Promise();
}

efetuaBusca(); // => "TypeError: Promise resolver is not a function"
</code>
                        </pre>
                        <p class="fragment">Porém, isso não será o suficiente para que funcione. O código acima resultará em <br><span class="highlight">TypeError: Promise resolver is not a function</span>.</p>
                    </section>

                    <section>
                        <p>Um detalhe importante é que na criação de uma Promise temos que passar como parâmetro uma função responsável pelo <span class="highlight">resolve</span> e <span class="highlight">reject</span>.</p>
                    </section>

                    <section>
                        <pre>
                            <code>function efetuaBusca() {
    new Promise(function(resolve, reject) {

    });
}

console.log(efetuaBusca()); // => undefined
</code>
                        </pre>
                    </section>

                    <section>
                        <p>Pronto, não teremos mais o erro, porém temos <span class="highlight">undefined</span> como retorno. Isso acontece porque não especificamos o retorno da nossa função efetuaBusca(). Precisamos definir nossa promise como retorno da nossa função.</p>
                    </section>

                    <section>
                        <pre>
                            <code>function efetuaBusca() {
    return new Promise((resolve, reject) => {

    });
}

console.log(efetuaBusca()); // => Promise {&lt;Pending&gt;}
</code>
                        </pre>
                        <p class="fragment">Agora temos como retorno uma<br> Promise com estado <span class="highlight">pending</span>.</p>
                    </section>

                    <section>
                        <p>Para resolver nossa Promise, podemos utilizar a função <span class="highlight">resolve</span> passando como parâmetro <br>um valor que será acessível através<br> de nossa Promise resolvida.</p>
                    </section>

                    <section>
                        <pre>
                            <code>function efetuaBusca() {
    new Promise(function(resolve, reject) {
        setTimeout(function() {
            resolve({
                foo: 'bar'
            });
        }), 5000);
    });
}

efetuaBusca().then(function(resultado) {
    console.log(resultado); // => {foo: 'bar'}
});
</code>
                        </pre>
                    </section>
				    
                    <section>
                        <p>Utilizamos um setTimeout para simular uma requisição que demoraria 5 segundo para retornar com a resposta. Quando passado os 5 segundos, <span class="highlight">resolve</span> será invocado passando como <span class="highlight">parâmetro o nosso objeto</span>, então <span class="highlight">then</span> é executado trazendo como parâmetro o nosso objeto esperado.</p>
                    </section>

                    <section>
                        <p>Assim como fizemos para resolver a <br>nossa Promise, também podemos <br>rejeitar utilizando <span class="highlight">reject</span>.</p>
                    </section>
                    
                    <section>
                        <pre>
                            <code>function efetuaBusca(foo) {
    new Promise(function(resolve, reject) {
        setTimeout(function() {
            if(foo) {
                return reject(new Error('Vixiii!!! Deu erro mano!!!'));
            }
            resolve({status: 'fagneranabalada!'});
        }, 5000);
    });
}
efetuaBusca(true)
    // then não foi executado
    .then(resultado => {
        console.log(resultado);
    })
    // catch foi executado trazendo como parâmetro a instância de Error passada no reject de nossa promise
    .catch(e => {
        console.error(e);
    });
</code>
                        </pre>
                    </section>

                    <section>
                        <b class="highlight">É isso, próximo!</b>
                    </section>
                </section>


                <section>
                    <section>
                        <b class="highlight">Tipos</b>
                    </section>
                    <section>
                        <p>Os tipos de JavaScript podem ser divididos em <span class="highlight">tipos primitivos</span> e <span class="highlight">tipos de objetos</span>.</p>
                    </section>
                    <section>
                        <p>E podem ser divididos em <br><span class="highlight">tipos com métodos</span> e <span class="highlight">tipos sem métodos</span>.</p>
                    </section>
                    <section>
                        <p>Também podem ser classificados como <br><span class="highlight">tipos mutáveis</span> e <span class="highlight">imutáveis</span>.</p>
                    </section>
                    <section>
                        <p>Um valor do tipo <span class="highlight">mutável <br> pode mudar</span>.</p>
                    </section>
                    <section>
                        <p><span class="highlight">Objetos</span> e <span class="highlight">arrays</span> são <span class="highlight">mutáveis</span>.</p>
                        <p class="fragment">JavaScript pode mudar os valores de propriedades do objeto e de elementos de arrays.</p>
                    </section>
                    <section>
                        <p><span class="highlight">Números</span>, <span class="highlight">booleanos</span>, <span class="highlight">null</span> e <span class="highlight">undefined</span> <br> são <span class="highlight">imutáveis</span>. </p>
                    </section>
                    <section>
                        <p>As <span class="highlight">strings</span> podem ser consideradas arrays de caractéres, sendo que se poderia <br>esperar que fossem mutáveis.</p>
                    </section>

                    <section>
                        <p>No entanto, em JavaScript as <span class="highlight">strings são imutáveis</span>.</p>
                    </section>

                    <section>
                        <p>Você pode acessar o texto de determinado índice de uma string, mas JavaScript não fornece uma maneira de alterar o texto de uma string existente.</p>
                    </section>

                    <section>
                        <p>Se você usa um valor não booleano onde é esperado um booleano, JavaScript <br> converte adequadamente.</p>
                    </section>

                    <section>
                        <p>As regras de conversão de valores literais de JavaScript afetam sua definição de igualdade, sendo que o operador de igualdade == <br>realiza a conversões de tipo. </p>
                    </section>

                    <section>
                        <p>ou seja...</p>
                        <pre class="fragment">
                            <code>console.log(1 == '1'); // => true
console.log(1 === '1'); // => false</code>
                        </pre>
                    </section>

                    <section>
                        <p>Tipos Primitivos</p>
                        <ul class="fragment highlight">
                            <li>String</li>
                            <li class="fragment">Number</li>
                            <li class="fragment">Boolean</li>
                        </ul>
                    </section>

                    <section>
                        <p>Tipos Compostos</p>
                        <ul class="fragment highlight">
                            <li>Object</li>
                            <li class="fragment">Array</li>
                        </ul>
                    </section>

                    <section>
                        <p>Valores especiais <span class="highlight">null</span> e <span class="highlight">undefined</span> são valores primitivos, porém são membros <br>de seu próprio tipo especial.</p>
                    </section>

                    <section>
                        <p>Qualquer valor em javascript que não seja string, booleano, null ou undefined é um objeto.</p>
                    </section>

                    <section>
                        <p>Javascript define um tipo especial de objeto conhecido como função. A função é um objeto que tem um código executável associado.</p>
                    </section>

                    <section>
                        <b class="highlight">É isso, próximo!</b>
                    </section>
                </section>

				<section>
				    
                    <section>
                        <b class="highlight">Boas práticas</b>
                    </section>

                    <section>
                    	<p><i>Você já parou pra pensar <br>que "o seu" código não é seu?</i></p>
                    </section>

                    <section>
                        <p>Pense no seguinte código:</p>
                        <pre class="fragment">
                            <code>function Carro(modelo, marca, ano) {
    this.modelo = modelo;
this.ano = ano;
        this.marca = marca;
}

var belina = new Carro('Belina')
var celta = new Carro('Celta');
var fusca = new Carro("Fusca")
</code>
                        </pre>
                    </section>

                    <section>
                        <p>Pode parecer besteira, mas a falta de padrão, faz você mesmo ficar em dúvida de como desenvolver.</p>
                    </section>

                    <section>
                        <p>Verifique se o projeto que você está mexendo já não tem algo definido como padrão.</p>
                    </section>
                    
                    <section>
                        <p>Vai utilizar o mesmo código várias vezes?</p>
                        <pre class="fragment">
                            <code>$('.elemento').addClass('red');

if($('.elemento').hasClass('red')) {
    $('.elemento').removeClass('red');
}</code>
                        </pre>
                    </section>

                    <section>
                        <p>Já pensou em reutilizar e otimizar?</p>
                        <pre class="fragment">
                            <code>var elemento = $('.elemento');
var cor = 'red';

elemento.addClass(cor);

if(elemento.hasClass(cor)) {
    elemento.removeClass(cor);
}</code>
                        </pre>
                    </section>

                    <section>
                        <p>e assim?</p>
                        <pre class="fragment">
                            <code>if($('.elemento').hasClass('red')) {
    $('.elemento').addClass('blue green');
} else if($('.elemento').hasClass('red1')) {
    $('.elemento').addClass('grey tomato');
} else if($('.elemento').hasClass('red2')) {
    $('.elemento').addClass('pink');
} else {
    $('.elemento').addClass('dark');    
}
</code>
                        </pre>
                    </section>

                    <section>
                        <p>poderia ser algo assim...</p>
                        <pre class="fragment">
                            <code>var elemento = $('.elemento');
var classe;

if(elemento.hasClass('red')) {
    classe = 'blue green';
} else if(elemento.hasClass('red1')) {
    classe = 'grey tomato';
} else if(elemento.hasClass('red2')) {
    classe = 'pink';
} else {
    classe = 'dark';
}

elemento.addClass(classe);
                            </code>
                        </pre>
                    </section>

                    <section>
                        <p>A facilidade em dar manutenção também é importante. Todos têm que conseguir mexer no seu código da maneira mais rápida e otimizada possível, sem precisar fazer gambiarras.</p>
                    </section>

                    <section>
                        <p>Você gostaria de ver uma situação dessas?</p>
                        <pre class="fragment">
                            <code>var x = 1; 
if(x) {
    x = 2;
    if(x) {
        x = 2;
        if(x) {
            x = 3;
            if(x) {
                x = 4;
            }
        } else {
            x = 0;
        }
    } else {
        x = 0;
    }
}
</code>
                        </pre>
                    </section>

                    <section>
                        <p>Se é difícil de ler, é difícil de dar manutenção.</p>
                        <p class="fragment highlight"><i>Não se apegue ao seu código!</i></p>
                    </section>

                    <section>
                        <b class="highlight">É isso, próximo!</b>
                    </section>
				</section>

				<section>
					<p><b class="highlight">Referências</b></p>
                    <ul>
					   <li><a href="https://developer.mozilla.org/" target="_blank">MDN</a></li>
					   <li><a href="https://www.youtube.com/channel/UCkqOofjb7nl6V8vXrIbGtiQ" target="_blank">Rodrigo Branas</a></li>
					   <li><a href="https://pt.wikipedia.org/" target="_blank">Wikipedia</a></li>
					   <li><a href="http://www.devmedia.com.br" target="_blank">Devmedia</a></li>
                    </ul>
				</section>

                <section>
                    <h2 class="highlight">É ISSO!</h2>
                </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				history: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
